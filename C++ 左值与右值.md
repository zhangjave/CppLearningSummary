# C++ 中的左值与右值

​		参考：[c++中的左值与右值 - twoon - 博客园 (cnblogs.com)](https://www.cnblogs.com/catch/p/3500678.html)

​		左值(lvalue)和右值(rvalue)是 c/c++ 中一个比较晦涩基础的概念，不少写了很久c/c++的人甚至没有听过这个名字，但这个概念到了 c++11 后却变得十分重要，它们是理解 move/forward 等新语义的基础。

## 左值与右值

​		左值与右值这两概念是从 c 中传承而来的，在 c 中，左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式).

```c
int a;
int b;

a = 3;
b = 4;
a = b;
b = a;

// 以下写法不合法。
3 = a;
a+b = 4;
```

​		在C++中，一个左值是指向一个指定内存的东西。另一方面，右值就是不指向任何地方的东西。通常来说，右值是暂时和短命的，而左值则活的很久，因为他们以变量的形式（variable）存在。我们可以将左值看作为容器（container）而将右值看做容器中的事物。如果容器消失了，容器中的事物也就自然就无法存在了。

1.  对于基础类型，右值是不可被修改的(non-modifiable)，也不可被 const, volatile 所修饰(cv-qualitification ignored)
2.  对于自定义的类型(user-defined types)，右值却允许通过它的成员函数进行修改。

```c++
int x = 666; // ok
```

在这里，`666`是一个右值。一个数字（从技术角度来说他是一个字面常量（literal constant））没有指定的内存地址，当然在程序运行时一些临时的寄存器除外。在该例中，`666`被赋值（assign）给`x`，`x`是一个变量。一个变量有着具体（specific）的内存位置，所以他是一个左值。C++中声明一个赋值（assignment）需要一个左值作为它的左操作数（left operand）：这完全合法。

```c++
int* y = &x; // ok
```

在这里我通过取地址操作符`&`获取了`x`的内存地址并且把它放进了`y`。`&`操作符需要一个左值并且产生了一个右值，这也是另一个完全合法的操作：在赋值操作符的左边我们有一个左值（一个变量），在右边我们使用取地址操作符产生的右值。
 然而，我们不能这样写：

```C++
int y;
666 = y; //error!

int* y = &666;//   error~
```

## 返回左值与右值的函数



## 左值到右值的转换



## 左值引用



## 右值应用




# 手机云勘大师国产化预言清单



## 一、前言

​		有待添加。



## 二、安装Python 3.6

### 2.1   安装包下载

下载离线安装包，并解压。

```sh

sudo apt-get http://xxxx.Python-3.6.8.tgz
tar -zxvf Python-3.6.1.tgz
cd Python-3.6.1/

```

### 2.2  编译安装

安装

```shell
# ./configure --prefix=/usr/local/ --enable-shared CFLAGS=-fPIC 
# prefix= 编译的时候用来指定程序存放路径 
./configure --prefix=/usr/local/python3 --enable-shared CFLAGS=-fPIC

make
make altinstall
```

### 2.3  配置为默认python环境

```shell
cp libpython3.6m.so.1.0 /usr/local/lib64/
cp libpython3.6m.so.1.0 /usr/lib/
cp libpython3.6m.so.1.0 /usr/lib64/


cd /usr/bin
mv python python.backup
ln -s /usr/local/bin/python3.6 /usr/bin/python
ln -s /usr/local/bin/python3.6 /usr/bin/python3

rm -rf /usr/bin/python2
ln -s /usr/bin/python2.7 /usr/bin/python2

```



## 三、编译boost.python库

### 3.1 下载boost库离线安装包

[Boost Downloads](https://www.boost.org/users/download/)

boost_1_69_0.tar.gz

### 3.2 编译安装

### python3版本的boost.python安装

1. 解压boost安装包，并进入到首层目录。

   tar -zxvf  boost_1_69_0.tar.gz

2. 执行配置，选择完全安装。此处要指定python3.6的位置，不同的linux系统有所不同，可以通过命令：`which python3`来查找路径。

   ```shell
   ./bootstrap.sh  --with-libraries=all --with-python=/usr/local/bin/python3.6m
   ```

3. 配置project-config.jam，编辑python相关目录，执行：

   ```shell
   vim project-config.jam
   ```

  4.打开文件后编辑 `using python` 字段，如下：

```sh
using python : 3.6 : /usr/bin/python3.6m : /usr/include/python3.6m : /usr/lib/python3.6 ;
```

表示的意义为：
版本号 ： 可执行文件位置：头文件目录：库文件目录

编译安装

```sh
sudo ./b2
# sudo ./b2 install --with-python include="/usr/include/python3.6m"  --prefix=/home/zjw/boost
sudo ./b2 install include="/usr/local/include/python3.6m"  --prefix=/home/zjw/boost
```

makefile:

```makefile
make
```



### 3.3 测试

#### 测试代码

```c++
#include <string>
#include <boost/python.hpp>

using namespace std;
using namespace boost::python;
	
struct World{
    void set(string msg) { this->msg = msg; }
    string greet() { return msg; }
    string msg;
};

//特别注意下面的模块名hello同将来引入Python的模块名、编译完成的文件名，三者必须相同 
BOOST_PYTHON_MODULE(hello){
   class_<World>("World")
        .def("greet", &World::greet)
        .def("set", &World::set)
   ;
}
```

#### 编译

```sh
#生成.o临时编译文件
g++ -fpic -c hello.cpp $(pkg-config --cflags python3)
#生成.so工作文件
g++ -shared -o hello.so hello.o -lboost_python36 $(pkg-config --cflags   

--libs python3)v  

export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
```

上面的两行编译命令中，有两个编译参数可能是需要根据具体版本做调整的，一个是pkg-config库管理工具中的python3，这个名称和版本号可以检查如下路径的配置文件，根据自己需要选择对应的库版本，比如python3对应需要有python3.pc文件：

```shell
ls /usr/local/lib/pkgconfig/python*pc
```

　另外一个是第二行命令中的-lboost_python37，这个检查已经安装的库版本来决定，比如-lboost_python37对应需要有libboost_python37.dylib文件，特别注意这个版本同将来运行的python环境版本必须精确一致，小版本也必须相同：

```sh
ls /usr/local/lib/libboost_python*
```

#### 验证

```python
import hello

test = hello.World()
test.set("HelloWorld")
test.greet()
```

#### bjam编译

boost官方推荐使用Boost.Build系统bjam来编译，比Makefile之类的确会略微的方便一点，这里介绍出来供参考。
安装bjam：`brew install bjam`。　

在当前目录建立一个文本文件Jamroot,内容为：

```bash
import python ;

using python : 3 ;

lib boost_python37 ;

project demo
  : requirements
    <location>.
    <library>boost_python37
  ;	
#注意下面的hello,同cpp文件中最后导出的模块名必须相同
python-extension hello
	: hello.cpp
	: <cxxflags>"`pkg-config --cflags python3`"
	: <linkflags>"`pkg-config --libs python3`"
	;
```

在命令行执行bjam命令，会自动编译生成hello.o及hello.dylib文件，.o文件为临时文件可以删除，.dylib文件改名为.so文件就是我们需要的Python扩展库，使用起来是完全相同的。

## 四、编译pyMyDatabase动态库

### 知识点一：g++链接静态库的方式

如果一个main.cpp文件中包含了a.h b.h头文件，而a.cpp b.cpp 已经通过编译指令：

```shell
       g++ -c a.cpp
       g++ -c b.cpp
       ar -cr libmix.a a.o b.o
```

将其源码文件编译成二进制存到了静态库libmix.a中了。
此时我们想编译main.cpp文件，可以有两种方法：

第一种：

```sh
   通过指令 g++ -o main main.cpp libmix.a
```

第二种：

```sh
 通过指令 g++ -o main main.cpp -L. -lmix
   
  其中-L. 是链接静态库的路径，在此路径为当前目录，语法为-Lpath
  -lmix    是静态库的名称标签，语法为-lxxx, 其中xxx省略了lib和.a后缀。
```
### 知识点二：g++链接动态库的方式



### 编译pyMyDatabase.so的命令

```sh
#  编译链接可执行文件时，增加 -Wl,--rpath=选项，链接器在可执行文件头中记录动态库的路径，动态加载器运行时读
#  取动态库路径，加载动态库。这种情况适用于主机开发运行环境：
#       g++ -L./yepanl -o main main.cc -ltest -Wl,--rpath=./yepanl
#  总结：-L选项用于链接时搜索动态库，-Wl,--rpath=用于运行时搜索动态库。

g++ -fPIC -shared pyMyDatabase.cpp Database.cpp Transaction.cpp Statement.cpp Column.cpp -o pyMyDatabase.so -I ./DataBase/include/ -I ./ -L ./DataBase/lib/linux_x64/ -Wl, -rpath=./DataBase/lib/linux_x64 -lssl -lsqlite3020001 -lboost_python36 -pthread -L ./ -I /usr/local/include/python3.6m
```

## 五、log4cplus在linux 下编译使用

```shell
# 解压
tar -zxvf log4cplus-1.2.1.tar.gz

# 设置安装目录 --enable-static 生成静态库   
./configure --prefix=/user/local/log4cplus --enable-static

make
make install
 
```

```sh
AppCloudCommon

g++ -fPIC -shared AppCloudCommon.cpp ./utils/ProcessUtil.cpp -I ./include/ -I ../3PartyLib/log4cplus/include/ -L ../3PartyLib/log4cplus/lib/ -llog4cplus -o AppCloudCommon.so
```



AppCloudCommon  CMakeLists.txt :

```cmake
# CMake 最低版本号要求
cmake_minimum_required (VERSION 3.16)

# 项目信息
project(AppCloudCommon)

file(GLOB ALL_SOURCES "*.cpp" "./utils/*.cpp")
add_library(AppCloudCommon SHARED ${ALL_SOURCES})


set_target_properities(AppCloudCommon PROPERTIES PROFIX "")

# 添加头文件路径
include_directories(
	./include/
	../3PartyLib/log4cplus/include/
)

# 设置需要链接的库  绝对路径
link_libraries("/home/**/lib/liblog4cplus.so")



```



## 六、Linux系统编译OpenSSL

6.1 准备工作
去https://www.openssl.org网站下载openssl源码
或用git命令从github上下载
git clone https://github.com/openssl/openssl.git

解压openssl开发包文件

```shell
tar -xzf openssl-1.1.0c.tar.gz
```

6.2.在终端下操作如下
进入刚才解压的文件夹


-设定Openssl 安装路径，( --prefix )参数为欲安装之目录，执行如下命令：

```shell
 ./config --prefix=/usr/local/openssl
```

6.3. 执行命令./config -t
6.4 .执行make命令，编译Openssl，编译需要等待一定的时间。
6.5 执行make install，安装 Openssl，安装也需要一定的时间。
安装完成后,openssl 会被安装到/usr/local/openssl 目录，包括头文件目录

进入lib后，libssl.a和libcrypto.a则为编译后的库文件

```shell
mv openssl-1.1.1.tar.gz ./openssl
gunzip openssl-1.1.1.tar.gz
tar -xvf openssl-1.1.1.tar
./config --prefix=/usr/local/openssl
make
make test
make install
cd /usr/local/openssl
ls
```

# 七、linux 下chromedriver的安装